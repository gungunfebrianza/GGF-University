# GGF University

> Prepare for the legacy, soon you will be history - Gun Gun Febrianza



## My Books :

- [x] **Belajar Dengan Jenius Deno - [Click](https://github.com/gungunfebrianza/Belajar-Dengan-Jenius-DenoTheWKWKLand)** 
- [x] **Belajar Dengan Jenius Node.js & AWS - [Click](https://github.com/gungunfebrianza/Belajar-Dengan-Jenius-AWS-Node.js)**
- [x] **Belajar Dengan Jenius Amazon IAM - [Click](https://github.com/gungunfebrianza/Belajar-Dengan-Jenius-AWS-IAM)**
- [x] **Belajar Dengan Jenius Golang  - [Click](https://github.com/gungunfebrianza/Belajar-Dengan-Jenius-Golang)**
- [x] **Develop Security Software With C# - [Click](https://github.com/gungunfebrianza/Develop-Security-Software-With-CSharp)**
- [ ] **Belajar Dengan Jenius Amazon Serverless**
- [ ] **Belajar Dengan Jenius Amazon RDS &Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon DynamoDB &Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon Lambda &Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon S3 &Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon SQS & Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon SES & Node.js/Deno**
- [ ] **Belajar Dengan Jenius Amazon EC2 & Node.js/Deno**
- [ ] **Belajar Dengan Jenius Algebra**

-----------------------------

## My Projects :

- **Visual Hashing - [Click](https://github.com/gungunfebrianza/Visual-Hashing)**
- **Stealth Monitor - [Click](https://github.com/gungunfebrianza/Security-Software-StealthMonitor)**
- **USB Disk Security - [Click](https://github.com/gungunfebrianza/USB-Disk-Security)**
- **Bedhil - GUI Task Automaton - [Click](https://github.com/gungunfebrianza/Bedhil---GUI-Task-Automaton)**

----------------------------------------------

## My Blockchain Research :

### Notes :

**Visualized Blockchain - Fundamental Concept** - [Click](https://medium.com/@hazekaizer/visualized-blockchain-fundamental-concept-131d9084c0b9)

### Book :

------------

## My Database Research :

### NoSQL Repository :

- [x] Mastering MongoDB - Click
- [x] **Mastering Mongoose** - [Click](https://github.com/gungunfebrianza/Mastering-Mongoose)
- [ ] Mastering Redis - Click
- [ ] Mastering Cassandra

### SQL :

- [ ] Mastering PostgreSQL

----------------------------------------------------------

## My Programming Repositories :

### Deno

- **Deno : Oak, JWT & PostgreSQL CRUD** - [Click](https://github.com/gungunfebrianza/Deno-Oak-JWT-CRUD)  

### Vanilla JavaScript

- **Mastering JavaScript** - 
- **Cryptography Examples** - [Click](https://github.com/gungunfebrianza/Mastering-Cryptography)

### Node.js

- **Mastering Node.js** - [Click](https://github.com/gungunfebrianza/Mastering-Node.js)

### D3.js

- **Mastering D3.js** - [Click](https://github.com/gungunfebrianza/Mastering-D3.js)

### Express.js

- **Mastering Express.js** - [Click](https://github.com/gungunfebrianza/Mastering-Express.js)

### React

- **Mastering React** - [Click](https://github.com/gungunfebrianza/Mastering-React) (Note: Probably Obsolete)

### HTML 5

- **Mastering HTML 5** - 
- **Mastering SVG** - 
- **Mastering Pug** - [Click](https://github.com/gungunfebrianza/Mastering-Pug) (Templating Engine)

### CSS

- **Mastering CSS** - 
- **Kujang Framework** - [Click](https://github.com/gungunfebrianza/kujang) 

### PHP

- **Mastering PHP** - [Click](https://github.com/gungunfebrianza/Mastering-PHP7)

------------------------------------

# Computer Science

## Algorithm

1. **Sorting.** Review of complexity and O-notation. Trivial sorting algorithms of quadratic complexity. Review of merge sort and quicksort, understanding their memory behaviour on statically allocated arrays. Heapsort. Stability. Other sorting methods including sorting in linear time. Median and order statistics.
2. **Strategies for algorithm design.** Dynamic programming, divide and conquer, greedy algorithms and other useful paradigms.
3. **Data structures.** Primitive data structures. Abstract data types. Pointers, stacks, queues, lists, trees. Binary search trees. Red-black trees. B-trees. Hash tables. Priority queues and heaps.
4. **Advanced data structures.** Amortized analysis: aggregate analysis, potential method. Fibonacci heaps. Disjoint sets.
5. **Graph algorithms.** Graph representations. Breadth-first and depth-first search. Topological sort. Minimum spanning tree. Kruskal and Prim algorithms. Single-source shortest paths: Bellman-Ford and Dijkstra algorithms. All-pairs shortest paths: matrix multiplication and Johnson’s algorithms. Maximum flow: Ford-Fulkerson method, Max-Flow Min-Cut Theorem. Matchings in bipartite graphs.
6. **Geometric algorithms.** Intersection of segments. Convex hull: Graham’s scan, Jarvis’s march.

## Data Structure

## Object-Oriented Programming

1. **Types, Objects and Classes Moving from functional to imperative.** Distinguishing state and behaviour. Primitive types. Function prototypes. Objects and classes as custom types. Introduction to parameterised types (templates/Generics).
2. **Pointers, References and Memory Pointers and references.** The call stack and heap. Iteration and recursion. Pass-by-value and pass-by-reference. Objects as reference types.
3. **Creating Classes Modularity**. Encapsulation. Information hiding. Access modifiers. Advantages of immutability. Creating Generic types. Static data.
4. **Inheritance Inheritance**. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.
5. **Polymorphism** and Multiple Inheritance Polymorphism. Multiple inheritance. Interfaces.
6. **Lifecycle of an Object Constructors and chaining.** Destructors. Finalizers. Garbage Collection. Copying Objects. Shallow and deep copies. Copy constructors.
7. **Design Patterns Introduction to design patterns.** Examples of Singleton, Decorator,
   State, Strategy, Observer.

## Mathematic

### Notes :

**Visualized Mathematic Fields** - [Click](https://medium.com/@hazekaizer/visualized-mathematic-fields-versio-c5c827200a17)

## Discrete Mathematic

1. **Proofs.** Proofs in practice and mathematical jargon. Mathematical statements: implication, bi-implication, universal quantification, conjunction, existential quantification, disjunction, negation. Logical deduction: proof strategies and patterns, scratch work,logical equivalences. Proof by contradiction. Divisibility and congruences. Fermat’s Little Theorem.
2. **Numbers**. Number systems: natural numbers, integers, rationals, modular integers. The Division Theorem and Algorithm. Modular arithmetic. Sets: membership and comprehension. The greatest common divisor, and Euclid’s Algorithm and Theorem. The Extended Euclid’s Algorithm and multiplicative inverses in modular arithmetic. The Diffie-Hellman cryptographic method. Mathematical induction: Binomial Theorem, Pascal’s Triangle, Fundamental Theorem of Arithmetic, Euclid’s infinity of primes.
3. **Sets.** Extensionality Axiom: subsets and supersets. Separation Principle: Russell’s Paradox, the empty set. Powerset Axiom: the powerset Boolean algebra, Venn and Hasse diagrams. Pairing Axiom: singletons, ordered pairs, products. Union axiom:
   big unions, big intersections, disjoint unions. Relations: composition, matrices, directed graphs, preorders and partial orders. Partial and (total) functions. Bijections: sections and retractions. Equivalence relations and set partitions. Calculus of bijections: characteristic (or indicator) functions. Finite cardinality and counting. Infinity axiom. Surjections. Enumerable and countable sets. Axiom of choice. Injections. Images: direct and inverse images. Replacement Axiom: set-indexed constructions. Set cardinality: Cantor-Schoeder-Bernstein Theorem, unbounded cardinality, diagonalisation, fixed-points. Foundation Axiom.
4. **Formal Language & Automata.** Introduction to inductive definitions using rules and proof by rule induction. Abstract
   syntax trees. Regular expressions and their algebra. Finite automata and regular languages: Kleene’s theorem and the Pumping Lemma.

## Compiler Construction

1. **Overview of compiler structure.** The spectrum of interpreters and compilers;
   compile-time and run-time. Structure of a simple compiler: lexical analysis and
   syntax analysis (details postponed to the last four lectures of term), type checking,
   intermediate representations, optimisations, code generation. Overview of run-time
   data structures: stack and heap. Virtual machines.
2. **Data structures, procedures/functions.** Representing tuples, arrays, references.
   Procedures and functions: calling conventions, nested structure, non-local variables.
   Functions as first-class values represented as closures. Simple optimisations: inline
   expansion, constant folding, elimination of tail recursion, peephole optimisation.
3. **Advanced topics.** Run-time memory management (garbage collection). Static and
   dynamic linking. Objects and inheritance; implementation of method dispatch.
   Try-catch exception mechanisms. How to compile a compiler via bootstrapping.
4. **Lexical analysis and syntax analysis.** Lexical analysis based on regular
   expressions and finite state automata. Using LEX-tools. How does LEX work?
   Parsing based on context-free grammars and push-down automata. Grammar
   ambiguity, left- and right-associativity and operator precedence. Using YACC-like
   tools. How does YACC work? LL(k) and LR(k) parsing theory.

## Operating System

1. Introduction to operating systems. Abstract view of an operating system. OS evolution: multi-programming, time-sharing. Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels. Elementary computer architecture.
2. **Processes and scheduling.** Job/process concepts. Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes.
3. **Memory management.** Processes in memory. Logical addresses. Partitions: static versus dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes.
4. **I/O subsystem.** General structure. Polled mode versus interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking versus non-blocking I/O. Other issues: caching, scheduling, spooling, performance.
5. **File management.** File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control.
6. **Unix.** Unix case study. History. General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection,
   pipes, signals. Character and block I/O. Process scheduling.

## Computer Architecture

## Computer Networking

1. **Introduction.** Overview of networking using the Internet as an example. LANs and WANs. OSI reference model, Internet TCP/IP Protocol Stack. Client/server paradigm, circuit-switching, packet-switching, Internet structure, networking delays
   and packet loss.
2. **Link layer and local area networks.** Link layer services, error detection and correction, Multiple Access Protocols, link layer addressing, Ethernet, hubs and switches, Point-to-Point Protocol.
3. **Wireless and mobile networks.** Wireless links and network characteristics, Wi-Fi: IEEE 802.11 wireless LANs, mobility management and mobile IP.
4. **Network layer addressing.** Network layer services, IP, IP addressing, IPv4, DHCP,
   NAT, ICMP, IPv6.
5. **Network layer routing.** Routing and forwarding, routing algorithms, routing in the
   Internet, RIP, OSPF, BGP, multicast.
6. **Transport layer**. Service models, multiplexing/demultiplexing, connection-less transport (UDP), principles of reliable data transfer, connection-oriented transport (TCP), TCP congestion control, securing TCP (SSL), TCP variants.
7. **Application layer.** Service requirements, WWW, HTTP, electronic mail, Domain
   Name System, P2P, socket programming API.
8. **Multimedia networking.** Networked multimedia applications, best-effort service and multimedia delivery requirements, multimedia protocols (RTSP, RTP, RTCP, SIP), content distribution networks.
9. **Datacenter Networking.** Datacenter introductions, architecting a datacenter, datacenter network and workload issues, datacenter transport issues.

## Distributed System

1. **Introduction to distributed systems; RPC.** Avantages and challenges of distributed systems; “middleware”; transparency goals; client-server systems; failures and retry semantics (all-or-nothing; at-most-once; at-least-once). Remote procedure call (RPC); marshalling; interface definition languages (IDLs); SunRPC; external data representation (XDR).
2. **Network File System and Object-Oriented Middleware.** Network File System (NFS); NFSv2; NFSv3; scoping; the implications of a stateless design; performance.
3. **Practical RPC systems; clocks.** Remote method invocation (RMI); remote classes vs. serialisable classes; distributed garbage collection; XML-RPC; SOAP and web services; REST. Physical clocks; UTC; computer clocks; clock synchronisation.
4. **Clock synchronisation; logical clocks.** Clock drift and compensation; Cristian’s
   Algorithm; Berkeley Algorithm; Network Time Protocol (NTP). Logical time,
   “happens-before”; Lamport clocks; vector clocks.
5. **Consistent cuts, process groups, and mutual exclusion.** Consistent global state;
   consistent cuts. Process groups; FIFO ordering; receiving vs. delivering; causal
   ordering; total ordering. Distributed mutual exclusion; central lock servers; token
   passing; totally ordered multicst.
6. **Elections, consensus, and distributed transactions Leader.** elections; ring-based
   algorithm; the Bully algorithm. Consensus. Distributed transactions; atomic commit
   protocols; 2-phase commit. Replication and consistency.
7. **Replication in distributed systems, CAP, case studies.** Replication and
   consistency (cont); strong consistency; quorum systems; weak consistency; FIFO
   consistency; eventual consistency; Amazone’s Dynamo; session guarantees;
   Consistency, Availability and Partitions (CAP); Google datacentre technologies
   (MapReduce).
8. **Further case studies, PubSub, security, NASD/AFS/Coda.** Google datacentre
   technologies (BigTable, Spanner). Access control and the access-control matrix;
   ACLs vs capabilities; cryptographic capabilities; role-

## Concurrent System

1. **Introduction to concurrency, threads, and mutual exclusion.** Introduction to concurrent systems; threads; interleaving; preemption; parallelism; execution orderings; processes and threads; kernel vs. user threads; M:N threads; atomicity; mutual exclusion; and mutual exclusion locks (mutexes).
2. **More mutual exclusion, semaphores, producer-consumer, and MRSW**. Hardware foundations for atomicity; locks and invariants; semaphores; condition synchronisation; N-resource allocation; two-party and generalised producer-consumer; Multi-Reader, Single-Write (MRSW) locks.
3. **CCR, monitors, and concurrency in practice.** Conditional critical regions (CCR); monitors; condition variables; signal-wait vs. signal-continue semantics; concurrency in practice.
4. **Safety and liveness.** Safety vs. liveness; deadlock; the Dining Philosophers; resource allocation graphs; deadlock prevention, avoidance, detection, and recovery; livelock; priority inversion; priority inheritance.
5. **Concurrency without shared data; transactions.** Active objects; message passing; tuple spaces; CSP; and actor models. Composite operations; transactions; ACID; isolation; and serialisability.
6. **Further transactions**. History graphs; good and bad schedules; isolation vs. strict isolation; 2-phase locking; rollback; timestamp ordering (TSO); and optimistic concurrency control (OCC).
7. **Crash recovery, lock-free programming, and transactional memory**. Write-ahead logging, checkpoints, and recovery. Lock-free programming and software-transactional memory (STM).
8. **Concurrent systems case study.** Concurrency in the kernel; kernel synchronisation before parallelism; Giant-locked kernels; fine-grained locking; primitives and strategies; lock order checking; network-stack work flows; performance scalability; the impact of changing hardware.

## Complexity Theory

1. **Algorithm Algorithms and problems.** Complexity of algorithms and of problems. Lower and upper bounds. Examples: sorting and travelling salesman.
2. **Time and space.** Models of computation and measures of complexity. Time and space complexity on a Turing machine. Decidability and complexity.
3. **Time complexity.** Time complexity classes. Polynomial time problems and
   algorithms. P and NP.
4. **Non-determinism.** Non-deterministic machines. The class NP redefined. Non-deterministic algorithms for reachability and satisfiability.
5. **NP-completeness.** Reductions and completeness. NP-completeness of satisfiability. Graph-theoretic problems. Hamiltonian cycle and clique. Sets, numbers and scheduling. Matching, set covering and bin packing.
6. **Cryptographic complexity.** One-way functions. 
7. **Space complexity.** Deterministic and non-deterministic space complexity classes. The reachability method. Savitch’s theorem.
8. **Hierarchy.** The time and space hierarchy theorems and complete problems.
9. **Descriptive complexity.** Logics capturing complexity classes. Fagin’s theorem.

